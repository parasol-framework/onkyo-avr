--[[ Network discovery for Onkyo receivers using UDP broadcast --]]

    include 'network'
    if not mNet then mNet = mod.load('network') end
    local eiscp = require('./lib/eiscp')

    local discovery = {}

    local DISCOVERY_PORT = 60128
    local DISCOVERY_TIMEOUT = 5.0
    local DISCOVERY_COMMANDS = {
       '!xECNQSTN', -- Extended device information query
       '!pECNQSTN'  -- Power status query
    }

----------------------------------------------------------------------------------------------------------------------
-- Utility functions

local function getNetworkInterfaces()
   local interfaces = {
      { addr = '127.0.0.1', broadcast = '255.255.255.255' } -- Default, broadcast from localhost
   }
   return interfaces
end

local function parseDeviceInfo(Response)
   -- Parse response format from discovery
   -- Can be: !1ECNTX-NR609/60128/DX/001122334455 or ECNTX-NR609/60128/DX/001122334455
   if not Response or #Response < 10 then
      return nil
   end

   -- Handle both formats: with or without !1ECN prefix
   local data = Response:match('^!1ECN(.+)$') or Response:match('^ECN(.+)$')
   if not data then
      return nil
   end

   local parts = {}
   for part in string.gmatch(data, '[^/]+') do
      table.insert(parts, part)
   end

   if #parts < 4 then
      msg('Warning: Incomplete device info: ' .. data)
      return {
         model = parts[1] or 'Unknown',
         port = tonumber(parts[2]) or DISCOVERY_PORT,
         area = parts[3] or 'Unknown',
         mac = parts[4] or 'Unknown'
      }
   end

   return {
      model = parts[1],
      port  = tonumber(parts[2]),
      area  = parts[3],
      mac   = parts[4],
      raw   = Response
   }
end

----------------------------------------------------------------------------------------------------------------------
-- Discovery implementation

function discovery.findReceivers(Timeout, FilterIP, Limit)
   Timeout = Timeout or DISCOVERY_TIMEOUT

   msg('Starting receiver discovery; Timeout: ' .. Timeout .. 's, Filter: ' .. nz(FilterIP,'NIL') .. ', Limit: ' .. nz(Limit, 'NIL'))

   local receivers = {}
   local proc = processing.new({ timeout = Timeout })
   local sockets = {}

   -- Create eISCP packets for discovery commands (use raw ISCP, not TCP-wrapped)
   local onkyoPacket = eiscp.createEISCPPacket('!xECNQSTN')
   local pioneerPacket = eiscp.createEISCPPacket('!pECNQSTN')

   -- Convert packet arrays to strings for transmission
   local function packetToString(packet)
      local str = ''
      for i = 1, #packet do
         str = str .. string.char(packet[i])
      end
      return str
   end

   local onkyoPacketStr = packetToString(onkyoPacket)
   local pioneerPacketStr = packetToString(pioneerPacket)
   local packetStrs = { onkyoPacketStr, pioneerPacketStr }

   local buffer = string.alloc(1024)
   local source = struct.new('IPAddress')
   local totalSent = 0
   local interfaces = getNetworkInterfaces()

   for _, interface in ipairs(interfaces) do
      msg('Using interface ' .. interface.addr .. ' -> broadcast ' .. interface.broadcast)

      for _, packetStr in ipairs(packetStrs) do
         -- Create socket that can both send and receive (like Python version)
         local socket = obj.new('netsocket', {
            flags = 'UDP|BROADCAST',
            incoming = function(Socket)
               local err, bytesRead = Socket.mtRecvFrom(source, buffer)
               if (err == ERR_Okay) and (bytesRead > 0) then
                  local senderIP = mNet.AddressToStr(source)
                  local senderPort = source.port

                  msg('Received ' .. bytesRead .. ' bytes from ' .. senderIP .. ':' .. senderPort)

                  -- Skip echo packets from our own machine
                  if senderIP == interface.addr then
                     msg('Skipping echo packet from our own interface')
                     return
                  end

                  -- Parse eISCP packet - convert string to byte array
                  local byteArray = {}
                  for i = 1, bytesRead do
                     byteArray[i] = string.byte(buffer, i)
                  end

                  local response = eiscp.parseEISCPResponse(byteArray)
                  if response then
                     msg('ISCP Message: ' .. response.data)

                     local deviceInfo = parseDeviceInfo(response.data)
                     if deviceInfo then
                        deviceInfo.ip = senderIP
                        deviceInfo.discovered_port = senderPort

                        -- Check if we already found this device
                        local found = false
                        for _, receiver in ipairs(receivers) do
                           if receiver.ip == senderIP and receiver.model == deviceInfo.model then
                              found = true
                              break
                           end
                        end

                        if not found then
                           table.insert(receivers, deviceInfo)
                           msg('Found receiver: ' .. deviceInfo.model .. ' at ' .. senderIP .. ':' .. deviceInfo.port .. ', Limit: ' .. nz(Limit, -1))
                           if Limit and #receivers >= Limit then
                              proc.signal()
                           elseif FilterIP and deviceInfo.ip == FilterIP then
                              proc.signal()
                           end
                        end
                     else
                        msg('Could not parse device info from ISCP message')
                     end
                  else
                     msg('Raw data (not eISCP): ' .. buffer:sub(1, math.min(bytesRead, 20)))
                  end
               elseif err != ERR_Okay then
                  msg('RecvFrom() error: ' .. mSys.GetErrorMsg(err))
               end
            end
         })

         if socket then
            -- Send to broadcast address
            local dest = struct.new('IPAddress')
            local addrErr = mNet.StrToAddress(interface.broadcast, dest)
            if addrErr == ERR_Okay then
               dest.port = DISCOVERY_PORT

               local err, bytesSent = socket.mtSendTo(dest, packetStr)
               if err == ERR_Okay then
                  totalSent = totalSent + 1
                  msg('Sent eISCP discovery packet to ' .. interface.broadcast .. ' (' .. bytesSent .. ' bytes)')
                  table.insert(sockets, socket)
               else
                  msg('Failed to send via interface ' .. interface.addr .. ': ' .. mSys.GetErrorMsg(err))
                  socket = nil
               end
            else
               msg('Failed to convert broadcast address ' .. interface.broadcast .. ': ' .. mSys.GetErrorMsg(addrErr))
               socket = nil
            end
         end
      end
   end

   if totalSent == 0 then
      msg('Failed to send any eISCP discovery packets')
      return
   end

   msg('Sent ' .. totalSent .. ' eISCP discovery packets, waiting for responses...')

   -- Wait for responses
   local startTime = mSys.PreciseTime()
   local result = proc.sleep()
   local duration = (mSys.PreciseTime() - startTime) / 1000000

   msg('Discovery completed in ' .. string.format('%.2f', duration) .. 's, found ' .. #receivers .. ' receivers')

   return receivers
end

function discovery.findReceiver(FilterIP, Timeout)
   local receivers
   if FilterIP then -- Return info for a specific receiver
      receivers = discovery.findReceivers(Timeout, FilterIP, nil)
   else -- Return the first receiver found
      receivers = discovery.findReceivers(Timeout, nil, 1)
   end

   if receivers and #receivers > 0 then
      return receivers[1]
   else
      msg('Failed to discover any receivers.')
   end
end

function discovery.listReceivers(Timeout)
   local receivers, err = discovery.findReceivers(Timeout, nil, nil)
   if err then
      print('Discovery error: ' .. err)
      return
   end

   if #receivers == 0 then
      print('No Onkyo receivers found on the network')
      return
   end

   print('Found ' .. #receivers .. ' Onkyo receiver(s):')
   print('')

   for i, receiver in ipairs(receivers) do
      print('  ' .. i .. '. ' .. receiver.model)
      print('     IP: ' .. (receiver.ip or 'Unknown'))
      print('     Port: ' .. (receiver.port or 'Unknown'))
      print('     Area: ' .. (receiver.area or 'Unknown'))
      print('     MAC: ' .. (receiver.mac or 'Unknown'))
      if receiver.raw then
         print('     Raw: ' .. receiver.raw)
      end
      print('')
   end
end

----------------------------------------------------------------------------------------------------------------------
-- Export public API

   return discovery
